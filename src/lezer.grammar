@precedence {left @left, right @right}

@top   PhiGrammar {PROGRAM}

@tokens {  
  COMMENT{ HASH ![\r\n]*}
  META{ PLUS FREE_NAME (space ![\r\n]+)?}
  
  ARRAY_STAR{ "*"}
  CONST{ "!"}
  COLON{ ":"}
  COPY{ "\'"}
  VERTEX{ "<"}
  ROOT{ 'Q'}
  SIGMA{ "&"}
  XI{ "$"}
  // QUESTION{ "?"}

  REGEX{ SLASH ![\r\n]+ SLASH}
  DOTS{ "..."}
  SLASH{ "/"}
  ARROW{ ">"}
  PLUS{ "+"}
  MINUS{ "-"}
  DOT{ "."}
  space{" "}
  LSQ[closedBy="RSQ"]{ "[" }
  RSQ[openedBy="LSQ"]{ "]"}
  LB[closedBy="RB"]{ "("}
  RB[openedBy="LB"]{ ")"}
  AT{ "@"}
  RHO{ "^"}
  HASH{ "#"}

  BYTE{ ($[0-9A-F])($[0-9A-F])}
  EMPTY_BYTES { MINUS MINUS}
  LINE_BYTES { BYTE (MINUS BYTE)*}

  BYTES {
      EMPTY_BYTES
    | LINE_BYTES
  }

  
  INT { (PLUS | MINUS)? ($[0-9] | $[1-9] $[0-9]+)}

  EXP { "e" (PLUS | MINUS)? $[0-9]+ }

  FLOAT { INT DOT $[0-9]* EXP?}

  BOOL{ "TRUE" | "FALSE"}
  CHAR{  "\'" (!["\\\r\n] | ESCAPE_SEQUENCE) "\'"}
  STRING{ "\"" (!["\\\r\n] | ESCAPE_SEQUENCE)* "\""}
  ESCAPE_SEQUENCE {
        "\\" $[btnfr"'\\]
      | "\\" ($[01]$[0-9]$[0-9] | "2"$[0-4]$[0-9] | "25" $[0-5])
      | "\\" "u" BYTE BYTE
  }
  
  HEX{ "0x" ($[0-9a-f])+}

  FREE_NAME{ $[a-z] ($[a-z0-9]| $[_-])*}
  FOREIGN_NAME {$[a-z] ($[a-z0-9]| $[_-])*}

  TEXT_MARK{ "\"\"\""}
  TEXT{
      TEXT_MARK ("\n" | "\r\n")
      (![\\] | ESCAPE_SEQUENCE)*
      TEXT_MARK
  }

  EOL {"\n"}

  @precedence {FLOAT, INT, HEX, BYTES, META}
  @precedence {TEXT, STRING}
  @precedence {REGEX, SLASH}
}

LICENSE
{
  (
    (!left COMMENT)
    EOL
  )+
}

METAS
{
  (
    META
    EOL
  )+
}

DATA
{
  BYTES
  |
  BOOL
  |
  TEXT
  |
  STRING
  |
  INT
  |
  FLOAT
  |
  HEX
  |
  CHAR
  |
  REGEX
}

HAS
{
  COLON
  FREE_NAME
}

PROGRAM
{
  LICENSE?
  METAS?
  EOL
  OBJECTS
}

OBJECTS
{
  (
    (
      !left
      COMMENT 
      EOL
    )*
    SPACES?
    OBJECT
    // EOL
  )+
}

// a sequence of spaces
SPACES {(!left space)+}



// --------------------------------
// main non-terminals
// --------------------------------



// ordinary object or class attribute
OBJECT
{
  DECLARATION
  EOL
  (
    !left
    SPACES
    DEFINITION
  )+
}

// first line in an object
DECLARATION
{
  // ~application_or_declaration
  DOT_NAME
  CONST?
  (
    (
      space
      SLASH
      FOREIGN_NAME
    )
  )?
  !left
  space
  ARROW
  (
    space
    FREE_LIST
  )?
}

// any name that can be accessed with a dot
DOT_NAME
{
  AT
  |
  RHO
  |
  XI
  |
  SIGMA
  |
  FREE_NAME
}

// .name | name.name.
// name.name
DOT_ACCESS
{
  (
    !left
    DOT
    DOT_NAME
  )+
}

APPLICATION
{
  // ~application_or_declaration
  DOT_NAME
  (
    !left
    DOT
    DOT_NAME
  )*
}

INVERSE_DOT
{
  DOT_NAME
  DOT
}

ACTION
{
  DOT_ACCESS
  |
  INVERSE_DOT
  |
  APPLICATION
}

// list of free attributes
// [name1 name2...]
FREE_LIST
{
  LSQ
  (
    FREE_NAME
    (
      space
      FREE_NAME
    )*
    DOTS?
  )?
  RSQ
}

INLINE_ATTRIBUTE
{
  LB
  DECLARATION
  space
  INLINE
  RB
}

ANONYMOUS
{
  FREE_LIST
  (
    !left
    space
    INLINE_ATTRIBUTE
  )*
  |
  ARRAY_STAR
  INLINE?
}

// part of an object after declaration
DEFINITION
{
  OBJECT
  |
  INLINE_EXPRESSION
}


PARENTHESIZED
{
  LB
  (
    INLINE
    |
    ANONYMOUS
  )
  RB
  (
    !left
    (
      DOT
      DOT_NAME
    )
  )*
}

ARGUMENT
{
  (
    FREE_NAME
    |
    AT
  )
  COLON
}

INLINE_TOKEN
{
  ARGUMENT?
  (
    PARENTHESIZED
    |
    DATA
    |
    ACTION
  )
}

INLINE_EXPRESSION
{
  INLINE
  EOL
}

INLINE
{
  INLINE_TOKEN
  (
    !left
    space
    INLINE_TOKEN
  )*
}